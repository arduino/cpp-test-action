name: Run C/C++ tests
description: Run tests, check for memory leaks, report code coverage

inputs:
  source-path:
    description: Path containing the CMakeLists.txt for the tests.
    required: true
    default: ${{ github.workspace }}/extras/test
  build-path:
    description: Path of the top-level folder for build output.
    required: true
    default: ${{ github.workspace }}/extras/test/build
  runtime-paths:
    description: YAML format list of paths to runtime binaries generated by building the tests.
    required: true
    default: "- ${{ github.workspace }}/extras/test/build/bin/unit-test-binary"
  coverage-exclude-paths:
    description: YAML format list of paths to remove from coverage data.
    required: true
    default: |
      - '*/extras/test/*'
      - '/usr/*'
      - '*/src/lib/*'
  coverage-data-path:
    description: Path to save the coverage data file to.
    required: true
    default: ${{ github.workspace }}/extras/test/build/coverage.info

runs:
  using: composite
  steps:
    - name: Build tests
      shell: bash
      run: |
        echo "::group::Run CMake on ${{ inputs.source-path }}"
        cmake -S "${{ inputs.source-path }}" -B "${{ inputs.build-path }}"
        echo "::endgroup::"
        echo "::group::Run Make on ${{ inputs.build-path }}"
        make --directory="${{ inputs.build-path }}"
        echo "::endgroup::"

    - name: Install yq
      shell: bash
      run: |
        sudo snap install yq > /dev/null

    - name: Update APT package lists
      shell: bash
      run: |
        sudo apt-get update > /dev/null

    - name: Install Valgrind
      shell: bash
      run: |
        sudo apt-get --assume-yes install valgrind > /dev/null

    - name: Run tests
      shell: bash
      run: |
        if [[ -n "${{ inputs.runtime-path }}" ]]; then
          echo "::warning::The runtime-path input is deprecated. Please use runtime-paths instead."
          RUNTIME_PATHS="${{ inputs.runtime-path }}"
        else
          RUNTIME_PATHS="${{ inputs.runtime-paths }}"
        fi

        EXIT_STATUS=0
        set +o errexit
        while IFS='' read -r runtimePath && [[ -n "$runtimePath" ]]; do
          echo "::group::Run $runtimePath with Valgrind"
          if ! valgrind --tool=memcheck --leak-check=yes --error-exitcode=1 "$runtimePath"; then
            EXIT_STATUS=1
            echo "::error file=$runtimePath::While running $runtimePath"
          fi
          echo "::endgroup::"
        done <<<"$(echo "$RUNTIME_PATHS" | yq read - [*])"
        exit $EXIT_STATUS

    - name: Parse coverage-exclude-paths input
      id: parse-coverage-exclude-paths
      shell: bash
      run: |
        while IFS='' read -r excludePath && [[ -n "$excludePath" ]]; do
          excludePaths="$excludePaths $excludePath"
        done <<<"$(echo "${{ inputs.coverage-exclude-paths }}" | yq read - [*])"
        # Make the parsed paths an output so it can be used by the next step
        echo "::set-output name=paths::$excludePaths"

    - name: Install LCOV
      shell: bash
      run: |
        sudo apt-get --assume-yes install lcov > /dev/null

    - name: Generate code coverage data
      shell: bash
      run: |
        echo "::group::Generate code coverage data from ${{ inputs.build-path }}"
        mkdir --parents "$(dirname -- "${{ inputs.coverage-data-path }}")"
        lcov --directory "${{ inputs.build-path }}" --capture --output-file "${{ inputs.coverage-data-path }}"
        set -o noglob
        lcov --quiet --remove "${{ inputs.coverage-data-path }}" ${{ steps.parse-coverage-exclude-paths.outputs.paths }} --output-file "${{ inputs.coverage-data-path }}"
        set +o noglob
        echo "::endgroup::"

    - name: Display coverage report in log
      shell: bash
      run: |
        echo "::group::Report code coverage"
        lcov --list "${{ inputs.coverage-data-path }}"
        echo "::endgroup::"
